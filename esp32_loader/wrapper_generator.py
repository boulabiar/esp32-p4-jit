import os


class WrapperGenerator:
    """
    Generate temp.c wrapper code for memory-mapped I/O argument passing.
    """
    
    def __init__(self, config, signature_data, original_source, arg_address):
        self.config = config
        self.signature = signature_data
        self.original_source_path = original_source
        self.original_source_basename = os.path.basename(original_source)
        # Generate header name from source
        self.header_name = os.path.splitext(self.original_source_basename)[0] + '.h'
        self.arg_address = arg_address
        self.args_array_size = config['wrapper']['args_array_size']
        
    def validate_args_count(self):
        """Validate argument count fits in array (reserve last slot for return)."""
        param_count = len(self.signature['parameters'])
        max_args = self.args_array_size - 1
        
        if param_count > max_args:
            raise ValueError(
                f"Function '{self.signature['name']}' has {param_count} parameters "
                f"but args array supports maximum {max_args} arguments.\n"
                f"Args array size: {self.args_array_size} slots "
                f"({self.args_array_size * 4} bytes)\n"
                f"Last slot [index {self.args_array_size - 1}] reserved for return value.\n"
                f"Solution: Increase 'args_array_size' in config/toolchain.yaml"
            )
    
    def calculate_return_index(self):
        """Calculate index for return value (last slot in array)."""
        return self.args_array_size - 1
    
    def generate_wrapper(self):
        """Generate complete wrapper code."""
        self.validate_args_count()
        
        code_parts = []
        
        code_parts.append(self._generate_header())
        code_parts.append(self._generate_includes())
        code_parts.append(self._generate_typedefs())
        code_parts.append(self._generate_function_start())
        code_parts.append(self._generate_io_pointer())
        code_parts.append(self._generate_arg_reads())
        code_parts.append(self._generate_function_call())
        code_parts.append(self._generate_result_write())
        code_parts.append(self._generate_function_end())
        
        return '\n'.join(code_parts)
    
    def _generate_header(self):
        """Generate file header comment."""
        func_name = self.signature['name']
        param_count = len(self.signature['parameters'])
        return_idx = self.calculate_return_index()
        
        return f"""// Auto-generated wrapper for {func_name}
// Generated by esp32-jit wrapper system
// Args array size: {self.args_array_size} slots ({self.args_array_size * 4} bytes)
// Arguments: {param_count} (slots 0-{param_count - 1 if param_count > 0 else 0})
// Return value: slot {return_idx}
"""
    
    def _generate_includes(self):
        """Generate include directive for generated header."""
        return f"""
#include <stdint.h>
#include "{self.header_name}"  // Include generated header

// Wrapper function to handle argument unpacking and return value
// Args are passed via a memory region (args_addr)
// [0..N-1]: Arguments
// [N]: Return value (if any)
typedef int esp_err_t;
#define ESP_OK 0
"""
    
    def _generate_typedefs(self):
        """Generate ESP-IDF typedefs."""
        # This method is now empty as its content has been moved to _generate_includes
        return ""
    
    def _generate_function_start(self):
        """Generate function signature."""
        wrapper_name = self.config['wrapper']['wrapper_entry']
        return f"""esp_err_t {wrapper_name}(void) {{"""
    
    def _generate_io_pointer(self):
        """Generate I/O pointer declaration."""
        return f"""    volatile int32_t *io = (volatile int32_t *)0x{self.arg_address:08x};
"""
    
    def _generate_arg_reads(self):
        """Generate code to read arguments from I/O memory."""
        lines = []
        
        for idx, param in enumerate(self.signature['parameters']):
            param_name = param['name']
            param_type = param['type']
            category = param['category']
            
            lines.append(f"    // Argument {idx}: {category.upper()} type {param_type}")
            
            if category == 'pointer':
                lines.append(f"    {param_type} {param_name} = ({param_type}) io[{idx}];")
            else:
                if 'float' in param_type or 'double' in param_type:
                    lines.append(f"    {param_type} {param_name} = *({param_type}*)& io[{idx}];")
                else:
                    lines.append(f"    {param_type} {param_name} = *({param_type}*)& io[{idx}];")
            
            lines.append("")
        
        return '\n'.join(lines)
    
    def _generate_function_call(self):
        """Generate function call to original function."""
        func_name = self.signature['name']
        return_type = self.signature['return_type']
        
        arg_names = [p['name'] for p in self.signature['parameters']]
        args_str = ', '.join(arg_names)
        
        lines = [f"    // Call original function: {func_name}"]
        
        if return_type == 'void':
            lines.append(f"    {func_name}({args_str});")
        else:
            lines.append(f"    {return_type} result = {func_name}({args_str});")
        
        lines.append("")
        
        return '\n'.join(lines)
    
    def _generate_result_write(self):
        """Generate code to write result to I/O memory."""
        return_type = self.signature['return_type']
        return_idx = self.calculate_return_index()
        
        if return_type == 'void':
            return f"    // No return value (void function)\n"
        
        lines = [f"    // Write result ({return_type}) to slot {return_idx}"]
        
        if 'float' in return_type or 'double' in return_type:
            lines.append(f"    io[{return_idx}] = *(int32_t*)& result;")
        elif '*' in return_type:
            lines.append(f"    io[{return_idx}] = (int32_t) result;")
        else:
            lines.append(f"    io[{return_idx}] = (int32_t) result;")
        
        lines.append("")
        
        return '\n'.join(lines)
    
    def _generate_function_end(self):
        """Generate function end."""
        return """    return ESP_OK;
}
"""
    
    def save_wrapper(self, output_dir):
        """
        Save generated wrapper to specified directory.
        
        Args:
            output_dir: Directory to save wrapper (source directory)
            
        Returns:
            str: Path to generated temp.c file
        """
        wrapper_code = self.generate_wrapper()
        
        template_file = self.config['wrapper']['template_file']
        output_path = os.path.join(output_dir, template_file)
        
        with open(output_path, 'w') as f:
            f.write(wrapper_code)
        
        return output_path
