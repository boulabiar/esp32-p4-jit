import os
from ..utils.logger import setup_logger, INFO_VERBOSE

logger = setup_logger(__name__)

class WrapperGenerator:
    """
    Generate temp.c wrapper code for memory-mapped I/O argument passing.
    Supports 64-bit types (int64, uint64, double) using 2 consecutive 32-bit slots.
    """

    # Types that require 64-bit (2 slots)
    _64BIT_TYPES = {'int64_t', 'uint64_t', 'int64', 'uint64', 'double',
                   'long long', 'unsigned long long', 'long long int',
                   'unsigned long long int'}

    def __init__(self, config, signature_data, original_source, arg_address):
        self.config = config
        self.signature = signature_data
        self.original_source_path = original_source
        self.original_source_basename = os.path.basename(original_source)
        # Generate header name from source
        self.header_name = os.path.splitext(self.original_source_basename)[0] + '.h'
        self.arg_address = arg_address
        self.args_array_size = config['wrapper']['args_array_size']

    def _is_64bit_type(self, type_str: str) -> bool:
        """Check if a type requires 64-bit (2 slots)."""
        # Remove const/volatile qualifiers and whitespace
        clean_type = type_str.replace('const', '').replace('volatile', '').strip()
        return clean_type in self._64BIT_TYPES

    def _calculate_slot_layout(self):
        """
        Calculate slot indices for each parameter and return value.
        Returns: list of (slot_index, slot_count) tuples for each param, plus return slot info
        """
        layout = []
        current_slot = 0

        for param in self.signature['parameters']:
            if param['category'] == 'pointer':
                # Pointers are always 32-bit on this platform
                slot_count = 1
            elif self._is_64bit_type(param['type']):
                slot_count = 2
            else:
                slot_count = 1

            layout.append((current_slot, slot_count))
            current_slot += slot_count

        # Return value uses last 1 or 2 slots depending on type
        return_type = self.signature['return_type']
        if return_type != 'void' and self._is_64bit_type(return_type):
            return_slot_count = 2
        else:
            return_slot_count = 1

        return layout, current_slot, return_slot_count
        
    def validate_args_count(self):
        """Validate argument slots fit in array (reserve slots for return)."""
        layout, total_param_slots, return_slot_count = self._calculate_slot_layout()

        # Total slots needed: param slots + return slots
        max_slots = self.args_array_size
        needed_slots = total_param_slots + return_slot_count

        if needed_slots > max_slots:
            logger.error(f"Slot count validation failed: {needed_slots} > {max_slots}")
            raise ValueError(
                f"Function '{self.signature['name']}' needs {needed_slots} slots "
                f"({total_param_slots} for args + {return_slot_count} for return) "
                f"but args array has {max_slots} slots.\n"
                f"Note: 64-bit types (int64, uint64, double) use 2 slots each.\n"
                f"Solution: Increase 'args_array_size' in config/toolchain.yaml"
            )

    def calculate_return_index(self):
        """Calculate index for return value (last 1 or 2 slots in array)."""
        return_type = self.signature['return_type']
        if return_type != 'void' and self._is_64bit_type(return_type):
            # 64-bit return uses 2 slots, return the first of the two
            return self.args_array_size - 2
        else:
            return self.args_array_size - 1
    
    def generate_wrapper(self):
        """Generate complete wrapper code."""
        self.validate_args_count()
        
        code_parts = []
        
        code_parts.append(self._generate_header())
        code_parts.append(self._generate_includes())
        code_parts.append(self._generate_typedefs())
        code_parts.append(self._generate_function_start())
        code_parts.append(self._generate_io_pointer())
        code_parts.append(self._generate_arg_reads())
        code_parts.append(self._generate_function_call())
        code_parts.append(self._generate_result_write())
        code_parts.append(self._generate_function_end())
        
        return '\n'.join(code_parts)
    
    def _generate_header(self):
        """Generate file header comment."""
        func_name = self.signature['name']
        param_count = len(self.signature['parameters'])
        return_idx = self.calculate_return_index()
        
        return f"""// Auto-generated wrapper for {func_name}
// Generated by esp32-jit wrapper system
// Args array size: {self.args_array_size} slots ({self.args_array_size * 4} bytes)
// Arguments: {param_count} (slots 0-{param_count - 1 if param_count > 0 else 0})
// Return value: slot {return_idx}
"""
    
    def _generate_includes(self):
        """Generate include directive for generated header."""
        return f"""
#include <stdint.h>
#include <string.h>  // For memcpy (strict aliasing safe type punning)
#include "{self.header_name}"  // Include generated header

// Wrapper function to handle argument unpacking and return value
// Args are passed via a memory region (args_addr)
// [0..N-1]: Arguments
// [N]: Return value (if any)
typedef int esp_err_t;
#define ESP_OK 0
"""
    
    def _generate_typedefs(self):
        """Generate ESP-IDF typedefs."""
        # This method is now empty as its content has been moved to _generate_includes
        return ""
    
    def _generate_function_start(self):
        """Generate function signature."""
        wrapper_name = self.config['wrapper']['wrapper_entry']
        return f"""esp_err_t {wrapper_name}(void) {{"""
    
    def _generate_io_pointer(self):
        """Generate I/O pointer declaration."""
        return f"""    volatile int32_t *io = (volatile int32_t *)0x{self.arg_address:08x};
"""
    
    def _generate_arg_reads(self):
        """Generate code to read arguments from I/O memory."""
        lines = []
        layout, _, _ = self._calculate_slot_layout()

        for idx, param in enumerate(self.signature['parameters']):
            param_name = param['name']
            param_type = param['type']
            category = param['category']
            slot_idx, slot_count = layout[idx]

            lines.append(f"    // Argument {idx}: {category.upper()} type {param_type} (slot {slot_idx}, {slot_count} slot(s))")

            if category == 'pointer':
                lines.append(f"    {param_type} {param_name} = ({param_type}) io[{slot_idx}];")
            elif slot_count == 2:
                # 64-bit type: read from 2 consecutive 32-bit slots (strict aliasing safe)
                lines.append(f"    {param_type} {param_name};")
                lines.append(f"    {{")
                lines.append(f"        uint32_t lo = (uint32_t)io[{slot_idx}];")
                lines.append(f"        uint32_t hi = (uint32_t)io[{slot_idx + 1}];")
                lines.append(f"        uint64_t combined = ((uint64_t)hi << 32) | lo;")
                lines.append(f"        memcpy(&{param_name}, &combined, sizeof({param_name}));")
                lines.append(f"    }}")
            else:
                # 32-bit type (strict aliasing safe with memcpy)
                lines.append(f"    {param_type} {param_name};")
                if 'float' in param_type:
                    lines.append(f"    memcpy(&{param_name}, &io[{slot_idx}], sizeof(float));")
                else:
                    lines.append(f"    memcpy(&{param_name}, &io[{slot_idx}], sizeof({param_type}));")

            lines.append("")

        return '\n'.join(lines)
    
    def _generate_function_call(self):
        """Generate function call to original function."""
        func_name = self.signature['name']
        return_type = self.signature['return_type']
        
        arg_names = [p['name'] for p in self.signature['parameters']]
        args_str = ', '.join(arg_names)
        
        lines = [f"    // Call original function: {func_name}"]
        
        if return_type == 'void':
            lines.append(f"    {func_name}({args_str});")
        else:
            lines.append(f"    {return_type} result = {func_name}({args_str});")
        
        lines.append("")
        
        return '\n'.join(lines)
    
    def _generate_result_write(self):
        """Generate code to write result to I/O memory."""
        return_type = self.signature['return_type']
        return_idx = self.calculate_return_index()

        if return_type == 'void':
            return f"    // No return value (void function)\n"

        is_64bit = self._is_64bit_type(return_type)
        slot_info = f"slot {return_idx}" if not is_64bit else f"slots {return_idx}-{return_idx+1}"
        lines = [f"    // Write result ({return_type}) to {slot_info}"]

        if '*' in return_type:
            # Pointers: Cast slot address to uint32_t* and write casted result
            lines.append(f"    *(uint32_t*)&io[{return_idx}] = (uint32_t)result;")
        elif is_64bit:
            # 64-bit type: write to 2 consecutive 32-bit slots (strict aliasing safe)
            lines.append(f"    {{")
            lines.append(f"        uint64_t raw;")
            lines.append(f"        memcpy(&raw, &result, sizeof(raw));")
            lines.append(f"        io[{return_idx}] = (int32_t)(raw & 0xFFFFFFFF);        // low 32 bits")
            lines.append(f"        io[{return_idx + 1}] = (int32_t)((raw >> 32) & 0xFFFFFFFF); // high 32 bits")
            lines.append(f"    }}")
        elif return_type == 'float':
            # Float: Cast slot address to float* and write result
            lines.append(f"    *(float*)&io[{return_idx}] = result;")
        else:
            # Integers (int8, uint8, int16, uint16, int32, uint32, etc.)
            lines.append(f"    *({return_type}*)&io[{return_idx}] = result;")

        lines.append("")

        return '\n'.join(lines)
    
    def _generate_function_end(self):
        """Generate function end."""
        return """    return ESP_OK;
}
"""
    
    def save_wrapper(self, output_dir):
        """
        Save generated wrapper to specified directory.
        
        Args:
            output_dir: Directory to save wrapper (source directory)
            
        Returns:
            str: Path to generated temp.c file
        """
        wrapper_code = self.generate_wrapper()
        
        template_file = self.config['wrapper']['template_file']
        output_path = os.path.join(output_dir, template_file)
        
        logger.log(INFO_VERBOSE, f"Saving wrapper code to {output_path}")
        with open(output_path, 'w') as f:
            f.write(wrapper_code)
        
        return output_path
